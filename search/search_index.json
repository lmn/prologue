{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Prologue What's past is prologue. Purpose Prologue is a Full-Stack Web Framework which is ideal for building elegant and high performance web services. Reduce magic. Reduce surprise. Documentation You can read documentation in https://planety.github.io/prologue. Core API docs in https://planety.github.io/prologue/coreapi/theindex.html. Plugin API docs in https://planety.github.io/prologue/plugin/theindex.html. Feature Core Base on httpx and asynchttpserver Configure and Settings Context Param and Query Data Form Data Static Files Middleware Simple Route Regex Route DSL Route CORS Response Signing Cookie Session Cache Startup and Shutdown Events URL Building Data Validation Exception Handler Cross-Site Request Forgery Cross-Site Scripting (XSS) Protection(Karax quote string automatically) Clickjacking Protection Authentication I18n Plugin Minimal OpenApi support Websocket support(https://github.com/xflywind/websocketx) Template(Using Karax Native) Test Client(Using httpclient) Command line tools(https://github.com/planety/logue) Installation First you should install Nim language which is an elegant and high performance language. Follow the instructions and set environment variables correctly. Then you can use nimble command to install prologue. nimble install prologue Usage Notes(important) If you use Linux or MacOS, you can use --threads:on to enable multi threads HTTP server. If you use windows and want to use multi-threads HTTP server, make sure use latest Nim devel version and enable --threads:on . In this situation, you can use -d:usestd to use asynchttpserver . Notes that multi threads may be slower than single-thread! If you want to benchmark prologue or release you programs, make sure set settings.debug = false. let # debug attributes must be false env = loadPrologueEnv ( \".env\" ) settings = newSettings ( appName = env . getOrDefault ( \"appName\" , \"Prologue\" ), debug = false , port = Port ( env . getOrDefault ( \"port\" , 8787 )), staticDirs = [ env . get ( \"staticDir\" ) ] , secretKey = env . getOrDefault ( \"secretKey\" , \"\" ) ) or in .env file, set debug = false . # Don't commit this to source control. # Eg. Make sure \".env\" in your \".gitignore\" file. debug = false # change this port = 8787 appName = HelloWorld staticDir =/ static secretKey = Pr435ol67ogue There are two ways to disable logging messages: (1) set settings.debug = false (2) set a startup event proc setLoggingLevel () = addHandler ( newConsoleLogger ()) logging . setLogFilter ( lvlInfo ) let event = initEvent ( setLoggingLevel ) var app = newApp ( settings = settings , middlewares = @[ debugRequestMiddleware () ] , startup = @[ event ] ) Hello World # app.nim import prologue proc hello * ( ctx : Context ) {. async .} = resp \"<h1>Hello, Prologue!</h1>\" let settings = newSettings () var app = newApp ( settings = settings ) app . addRoute ( \"/\" , hello ) app . run () Run app.nim . Now the server is running at localhost:8080. Another example # app.nim import prologue import prologue / middlewares # Async Function proc home * ( ctx : Context ) {. async .} = resp \"<h1>Home</h1>\" proc helloName * ( ctx : Context ) {. async .} = resp \"<h1>Hello, \" & ctx . getPathParams ( \"name\" , \"Prologue\" ) & \"</h1>\" proc doRedirect * ( ctx : Context ) {. async .} = resp redirect ( \"/hello\" ) proc login * ( ctx : Context ) {. async .} = resp loginPage () proc do_login * ( ctx : Context ) {. async .} = resp redirect ( \"/hello/Nim\" ) let settings = newSettings ( appName = \"StarLight\" ) var app = newApp ( settings = settings , middlewares = @[ debugRequestMiddleware () ] ) app . addRoute ( \"/\" , home , @[ HttpGet , HttpPost ] ) app . addRoute ( \"/home\" , home , HttpGet ) app . addRoute ( \"/redirect\" , doRedirect , HttpGet ) app . addRoute ( \"/login\" , login , HttpGet ) app . addRoute ( \"/login\" , do_login , HttpPost , middlewares = @[ debugRequestMiddleware () ] ) app . addRoute ( \"/hello/{name}\" , helloName , HttpGet ) app . run () Run app.nim . Now the server is running at localhost:8080. DSL for routes You can read docs in https://nim-lang.github.io/Nim/with.html and construct your own DSL. Pseudocode: import std / with with app : get \"/\" , home post \"/\" , home get \"/home\" , home get \"/home\" , home get \"/redirect\" , doRedirect get \"/login\" , login post ( \"/login\" , login , middlewares = debugRequestMiddleware ()) get \"/hello/{name}\" , helloName addRoute [ HttpGet , HttpPost ] , helloRoute Run app.nim . Now the server is running at localhost:8080. More examples HelloWorld ToDoList ToDoApp Blog Extensions If you need more extensions, you can refer to awesome prologue and awesome nim . Donate Thanks for supporting me. buy me a coffee patreon Stars","title":"Introduction"},{"location":"#prologue","text":"What's past is prologue.","title":"Prologue"},{"location":"#purpose","text":"Prologue is a Full-Stack Web Framework which is ideal for building elegant and high performance web services. Reduce magic. Reduce surprise.","title":"Purpose"},{"location":"#documentation","text":"You can read documentation in https://planety.github.io/prologue. Core API docs in https://planety.github.io/prologue/coreapi/theindex.html. Plugin API docs in https://planety.github.io/prologue/plugin/theindex.html.","title":"Documentation"},{"location":"#feature","text":"Core Base on httpx and asynchttpserver Configure and Settings Context Param and Query Data Form Data Static Files Middleware Simple Route Regex Route DSL Route CORS Response Signing Cookie Session Cache Startup and Shutdown Events URL Building Data Validation Exception Handler Cross-Site Request Forgery Cross-Site Scripting (XSS) Protection(Karax quote string automatically) Clickjacking Protection Authentication I18n Plugin Minimal OpenApi support Websocket support(https://github.com/xflywind/websocketx) Template(Using Karax Native) Test Client(Using httpclient) Command line tools(https://github.com/planety/logue)","title":"Feature"},{"location":"#installation","text":"First you should install Nim language which is an elegant and high performance language. Follow the instructions and set environment variables correctly. Then you can use nimble command to install prologue. nimble install prologue","title":"Installation"},{"location":"#usage","text":"","title":"Usage"},{"location":"#notesimportant","text":"If you use Linux or MacOS, you can use --threads:on to enable multi threads HTTP server. If you use windows and want to use multi-threads HTTP server, make sure use latest Nim devel version and enable --threads:on . In this situation, you can use -d:usestd to use asynchttpserver . Notes that multi threads may be slower than single-thread! If you want to benchmark prologue or release you programs, make sure set settings.debug = false. let # debug attributes must be false env = loadPrologueEnv ( \".env\" ) settings = newSettings ( appName = env . getOrDefault ( \"appName\" , \"Prologue\" ), debug = false , port = Port ( env . getOrDefault ( \"port\" , 8787 )), staticDirs = [ env . get ( \"staticDir\" ) ] , secretKey = env . getOrDefault ( \"secretKey\" , \"\" ) ) or in .env file, set debug = false . # Don't commit this to source control. # Eg. Make sure \".env\" in your \".gitignore\" file. debug = false # change this port = 8787 appName = HelloWorld staticDir =/ static secretKey = Pr435ol67ogue There are two ways to disable logging messages: (1) set settings.debug = false (2) set a startup event proc setLoggingLevel () = addHandler ( newConsoleLogger ()) logging . setLogFilter ( lvlInfo ) let event = initEvent ( setLoggingLevel ) var app = newApp ( settings = settings , middlewares = @[ debugRequestMiddleware () ] , startup = @[ event ] )","title":"Notes(important)"},{"location":"#hello-world","text":"# app.nim import prologue proc hello * ( ctx : Context ) {. async .} = resp \"<h1>Hello, Prologue!</h1>\" let settings = newSettings () var app = newApp ( settings = settings ) app . addRoute ( \"/\" , hello ) app . run () Run app.nim . Now the server is running at localhost:8080.","title":"Hello World"},{"location":"#another-example","text":"# app.nim import prologue import prologue / middlewares # Async Function proc home * ( ctx : Context ) {. async .} = resp \"<h1>Home</h1>\" proc helloName * ( ctx : Context ) {. async .} = resp \"<h1>Hello, \" & ctx . getPathParams ( \"name\" , \"Prologue\" ) & \"</h1>\" proc doRedirect * ( ctx : Context ) {. async .} = resp redirect ( \"/hello\" ) proc login * ( ctx : Context ) {. async .} = resp loginPage () proc do_login * ( ctx : Context ) {. async .} = resp redirect ( \"/hello/Nim\" ) let settings = newSettings ( appName = \"StarLight\" ) var app = newApp ( settings = settings , middlewares = @[ debugRequestMiddleware () ] ) app . addRoute ( \"/\" , home , @[ HttpGet , HttpPost ] ) app . addRoute ( \"/home\" , home , HttpGet ) app . addRoute ( \"/redirect\" , doRedirect , HttpGet ) app . addRoute ( \"/login\" , login , HttpGet ) app . addRoute ( \"/login\" , do_login , HttpPost , middlewares = @[ debugRequestMiddleware () ] ) app . addRoute ( \"/hello/{name}\" , helloName , HttpGet ) app . run () Run app.nim . Now the server is running at localhost:8080.","title":"Another example"},{"location":"#dsl-for-routes","text":"You can read docs in https://nim-lang.github.io/Nim/with.html and construct your own DSL. Pseudocode: import std / with with app : get \"/\" , home post \"/\" , home get \"/home\" , home get \"/home\" , home get \"/redirect\" , doRedirect get \"/login\" , login post ( \"/login\" , login , middlewares = debugRequestMiddleware ()) get \"/hello/{name}\" , helloName addRoute [ HttpGet , HttpPost ] , helloRoute Run app.nim . Now the server is running at localhost:8080.","title":"DSL for routes"},{"location":"#more-examples","text":"HelloWorld ToDoList ToDoApp Blog","title":"More examples"},{"location":"#extensions","text":"If you need more extensions, you can refer to awesome prologue and awesome nim .","title":"Extensions"},{"location":"#donate","text":"Thanks for supporting me. buy me a coffee patreon","title":"Donate"},{"location":"#stars","text":"","title":"Stars"},{"location":"application/","text":"application Prologue object is used to configure the application, do some preparations before requests. The hello world example is suitable for learning Prologue object. startup and shutdown events You can set startup events which executes before the application starts and shutdown events after the application stops. You can read the events document later. serve static files Prologue can serve static files, you can read the staticFile documents later. routes You can add all kinds of routes to route table and read the routes document later. middlewares You can use and write middlewares . upload files you can get the info of uploadFile and save it to disks.","title":"Application"},{"location":"application/#application","text":"Prologue object is used to configure the application, do some preparations before requests. The hello world example is suitable for learning Prologue object.","title":"application"},{"location":"application/#startup-and-shutdown-events","text":"You can set startup events which executes before the application starts and shutdown events after the application stops. You can read the events document later.","title":"startup and shutdown events"},{"location":"application/#serve-static-files","text":"Prologue can serve static files, you can read the staticFile documents later.","title":"serve static files"},{"location":"application/#routes","text":"You can add all kinds of routes to route table and read the routes document later.","title":"routes"},{"location":"application/#middlewares","text":"You can use and write middlewares .","title":"middlewares"},{"location":"application/#upload-files","text":"you can get the info of uploadFile and save it to disks.","title":"upload files"},{"location":"context/","text":"Context Context is initialized when a new request enters. Context utils getPostParams: gets the parameters by HttpPost. getQueryParams: gets the query strings(for example, \"www.google.com/hello?name=12\", name=12 ). getPathParams: gets the route parameters(for example, \"/hello/{name}\"). setResponse: it is handy to make the response of ctx . attachment: attachment is used to specify the file will be downloaded. staticFileResponse: serves static files. getUploadFile: gets the UploadFile from request. save: saves the UploadFile to disk.","title":"Context"},{"location":"context/#context","text":"Context is initialized when a new request enters.","title":"Context"},{"location":"context/#context-utils","text":"getPostParams: gets the parameters by HttpPost. getQueryParams: gets the query strings(for example, \"www.google.com/hello?name=12\", name=12 ). getPathParams: gets the route parameters(for example, \"/hello/{name}\"). setResponse: it is handy to make the response of ctx . attachment: attachment is used to specify the file will be downloaded. staticFileResponse: serves static files. getUploadFile: gets the UploadFile from request. save: saves the UploadFile to disk.","title":"Context utils"},{"location":"event/","text":"Prologue supports both startup and shutdown events. startup events will be only executed once before the main loop. In contrast, shutdown events will be executed once after the main loop. Let's first look at the structure of Event , you can see that Event supports both synchronous and asynchronous closure function pointers. type AsyncEvent * = proc (): Future [ void ] {. closure , gcsafe .} SyncEvent * = proc () {. closure , gcsafe .} Event * = object case async * : bool of true : asyncHandler * : AsyncEvent of false : syncHandler * : SyncEvent You can use initEvent and pass function pointers to create Event . proc initEvent * ( handler : AsyncEvent ): Event {. inline .} = Event ( async : true , asyncHandler : handler ) proc initEvent * ( handler : SyncEvent ): Event {. inline .} = Event ( async : false , syncHandler : handler ) newApp has startup and shutdown parameters. You can pass a sequence of events to newApp . proc newApp * ( settings : Settings , middlewares : sink seq [ HandlerAsync ] = @[] , startup : seq [ Event ] = @[] , shutdown : seq [ Event ] = @[] , errorHandlerTable = DefaultErrorHandler , appData = newStringTable ( mode = modeCaseSensitive )): Prologue = Here is an example for a startup event(A shutdown event has the same usage as a startup event). proc setLoggingLevel () = addHandler ( newConsoleLogger ()) logging . setLogFilter ( lvlInfo ) let event = initEvent ( setLoggingLevel ) var app = newApp ( settings = settings , middlewares = @[ debugRequestMiddleware () ] , startup = @[ event ] )","title":"Event"},{"location":"middleware/","text":"Middlewares Write a middleware Middleware is like an onion. a request -> middlewareA does something -> middlewareB does something -> handler does something -> middlewareB does something -> middlewareA does something -> a response Don't forget await switch(ctx) to enter next middleware or handler. Then you can set global middlewares which are visible to all handlers. Or you can make them only visible to some middlewares. import logging import prologue proc hello ( ctx : Context ) {. async .} = discard proc myDebugRequestMiddleware * ( appName = \"Starlight\" ): HandlerAsync = result = proc ( ctx : Context ) {. async .} = logging . info \"debugRequestMiddleware->begin\" # do something before await switch ( ctx ) # do something after logging . info \"debugRequestMiddleware->End\" var settings = newSettings () app = newApp ( settings = settings , middlewares = @[ myDebugRequestMiddleware () ] ) app . addRoute ( \"/\" , hello , HttpGet , middlewares = @[ myDebugRequestMiddleware () ] ) You can put your middleware plugin in collections . Use a middleware prologue also supplies some middleware plugins, you can directly import them. import prologue / middlewares For better compilation time, you could import them directly. import prologue / middlewares / signedcookiesession # or import prologue / middlewares / utils # or import prologue / middlewares / cors","title":"Middleware"},{"location":"middleware/#middlewares","text":"","title":"Middlewares"},{"location":"middleware/#write-a-middleware","text":"Middleware is like an onion. a request -> middlewareA does something -> middlewareB does something -> handler does something -> middlewareB does something -> middlewareA does something -> a response Don't forget await switch(ctx) to enter next middleware or handler. Then you can set global middlewares which are visible to all handlers. Or you can make them only visible to some middlewares. import logging import prologue proc hello ( ctx : Context ) {. async .} = discard proc myDebugRequestMiddleware * ( appName = \"Starlight\" ): HandlerAsync = result = proc ( ctx : Context ) {. async .} = logging . info \"debugRequestMiddleware->begin\" # do something before await switch ( ctx ) # do something after logging . info \"debugRequestMiddleware->End\" var settings = newSettings () app = newApp ( settings = settings , middlewares = @[ myDebugRequestMiddleware () ] ) app . addRoute ( \"/\" , hello , HttpGet , middlewares = @[ myDebugRequestMiddleware () ] ) You can put your middleware plugin in collections .","title":"Write a middleware"},{"location":"middleware/#use-a-middleware","text":"prologue also supplies some middleware plugins, you can directly import them. import prologue / middlewares For better compilation time, you could import them directly. import prologue / middlewares / signedcookiesession # or import prologue / middlewares / utils # or import prologue / middlewares / cors","title":"Use a middleware"},{"location":"quickstart/","text":"Quick Start hello world Now Let's begin a quick tour of Prologue . # app.nim import prologue proc hello * ( ctx : Context ) {. async .} = resp \"<h1>Hello, Prologue!</h1>\" let settings = newSettings () var app = newApp ( settings = settings ) app . addRoute ( \"/\" , hello ) app . run () This is a very basic \"Hello Prologue\" example.Run this script, visit http://localhost:8080 and you will see \"Hello, Prologue!\" in your browser! Here is how it works. First we import prologue to include all things we need in this example. Then let's look at hello function. It generates html or plain text or json or something else to our default http server(asynchttpserver). Function parameters ctx is of Context type. Context carry all things in every request. It includes request from http server and response which we transfer to http server Correspondingly and other useful attributes. In function body, we can find resp . resp is handy for generating response we need. It is equal to ctx.response = initResponse(\"<h1>Hello, Prologue!</h1>\") . Next let's configure our application. For this basic example, we will use default settings. You can specify parameters of newSettings of course. You can change to other port or set debug flag. Next let's add route to our application. Finally just run our application. Command line tool You can also install logue to initialize your program. nimble install logue Make sure ~/.nimble/bin is in your environment variables. Type command logue init helloworld to initialize. This will create program structure like this: - helloworld .env app.nim urls.nim views.nim You must switch to /.../helloworld directory to run app.nim .","title":"QuickStart"},{"location":"quickstart/#quick-start","text":"","title":"Quick Start"},{"location":"quickstart/#hello-world","text":"Now Let's begin a quick tour of Prologue . # app.nim import prologue proc hello * ( ctx : Context ) {. async .} = resp \"<h1>Hello, Prologue!</h1>\" let settings = newSettings () var app = newApp ( settings = settings ) app . addRoute ( \"/\" , hello ) app . run () This is a very basic \"Hello Prologue\" example.Run this script, visit http://localhost:8080 and you will see \"Hello, Prologue!\" in your browser! Here is how it works. First we import prologue to include all things we need in this example. Then let's look at hello function. It generates html or plain text or json or something else to our default http server(asynchttpserver). Function parameters ctx is of Context type. Context carry all things in every request. It includes request from http server and response which we transfer to http server Correspondingly and other useful attributes. In function body, we can find resp . resp is handy for generating response we need. It is equal to ctx.response = initResponse(\"<h1>Hello, Prologue!</h1>\") . Next let's configure our application. For this basic example, we will use default settings. You can specify parameters of newSettings of course. You can change to other port or set debug flag. Next let's add route to our application. Finally just run our application.","title":"hello world"},{"location":"quickstart/#command-line-tool","text":"You can also install logue to initialize your program. nimble install logue Make sure ~/.nimble/bin is in your environment variables. Type command logue init helloworld to initialize. This will create program structure like this: - helloworld .env app.nim urls.nim views.nim You must switch to /.../helloworld directory to run app.nim .","title":"Command line tool"},{"location":"request/","text":"Request You can visit request by ctx.request . Request utils request.url: gets the url of the request request.port: gets the port of the request request.path: gets the path of the request. request.reqMethod: gets the HttpMethod of the request. request.contentType: gets the contentType of the request. request.hostName: gets the hostname of the request.","title":"Requests"},{"location":"request/#request","text":"You can visit request by ctx.request .","title":"Request"},{"location":"request/#request-utils","text":"request.url: gets the url of the request request.port: gets the port of the request request.path: gets the path of the request. request.reqMethod: gets the HttpMethod of the request. request.contentType: gets the contentType of the request. request.hostName: gets the hostname of the request.","title":"Request utils"},{"location":"response/","text":"Response Respond by types You can specify different responses by types. - htmlResponse -> HTML format - plainTextResponse -> Plain Text format - jsonResponse -> Json format Respond by error code error404 -> return 404 redirect -> return 301 and redirect to a new page abort -> return 401 Other utils You can set the cookie and header of the response. SetCookie : sets the cookie of the response. DeleteCookie : deletes the cookie of the response. setHeader : sets the header values of the response. addHeader : adds header values to the existing HttpHeaders .","title":"Response"},{"location":"response/#response","text":"","title":"Response"},{"location":"response/#respond-by-types","text":"You can specify different responses by types. - htmlResponse -> HTML format - plainTextResponse -> Plain Text format - jsonResponse -> Json format","title":"Respond by types"},{"location":"response/#respond-by-error-code","text":"error404 -> return 404 redirect -> return 301 and redirect to a new page abort -> return 401","title":"Respond by error code"},{"location":"response/#other-utils","text":"You can set the cookie and header of the response. SetCookie : sets the cookie of the response. DeleteCookie : deletes the cookie of the response. setHeader : sets the header values of the response. addHeader : adds header values to the existing HttpHeaders .","title":"Other utils"},{"location":"route/","text":"Route Route is the core of web framework. Static Route Register handler hello by specifying path, httpMethod and middlewares. Default http method is HttpGet .If you register a handler with HttpGet , Prologue will automatically register HttpHead for this handler. # handler proc hello * ( ctx : Context ) {. async .} = resp \"<h1>Hello, Prologue!</h1>\" app . addRoute ( \"/hello\" , hello ) You can also use seq[httpMetod] to register same handler but support different http methods. # handler proc hello * ( ctx : Context ) {. async .} = resp \"<h1>Hello, Prologue!</h1>\" app . addRoute ( \"/hello\" , hello , @[ HttpGet , HttpPost ] ) Parameters Route Prologue support parameters route.You can use getPathParams to get name argument. proc helloName * ( ctx : Context ) {. async .} = resp \"<h1>Hello, \" & ctx . getPathParams ( \"name\" , \"Prologue\" ) & \"</h1>\" app . addRoute ( \"/hello/{name}\" , helloName , HttpGet ) Regex Route Prologue support regex route.You can use getPathParams to get name argument. proc articles * ( ctx : Context ) {. async .} = resp $ ctx . getPathParams ( \"num\" , 1 ) app . addRoute ( re\"/post(?P<num>[\\d]+)\" , articles , HttpGet )","title":"Route"},{"location":"route/#route","text":"Route is the core of web framework.","title":"Route"},{"location":"route/#static-route","text":"Register handler hello by specifying path, httpMethod and middlewares. Default http method is HttpGet .If you register a handler with HttpGet , Prologue will automatically register HttpHead for this handler. # handler proc hello * ( ctx : Context ) {. async .} = resp \"<h1>Hello, Prologue!</h1>\" app . addRoute ( \"/hello\" , hello ) You can also use seq[httpMetod] to register same handler but support different http methods. # handler proc hello * ( ctx : Context ) {. async .} = resp \"<h1>Hello, Prologue!</h1>\" app . addRoute ( \"/hello\" , hello , @[ HttpGet , HttpPost ] )","title":"Static Route"},{"location":"route/#parameters-route","text":"Prologue support parameters route.You can use getPathParams to get name argument. proc helloName * ( ctx : Context ) {. async .} = resp \"<h1>Hello, \" & ctx . getPathParams ( \"name\" , \"Prologue\" ) & \"</h1>\" app . addRoute ( \"/hello/{name}\" , helloName , HttpGet )","title":"Parameters Route"},{"location":"route/#regex-route","text":"Prologue support regex route.You can use getPathParams to get name argument. proc articles * ( ctx : Context ) {. async .} = resp $ ctx . getPathParams ( \"num\" , 1 ) app . addRoute ( re\"/post(?P<num>[\\d]+)\" , articles , HttpGet )","title":"Regex Route"},{"location":"session/","text":"Session The session helps with storing users' state. Session based on signed cookie This session is based on signed cookie. It is not safe . You must not use it to store sensitive or important infos except for testing. Prologue provides sessionMiddleware to you. Usage First you should register sessionMiddleware in global middlewares or hanler's middlewares. var app = newApp ( settings = settings , middlewares = @[ sessionMiddleware ( secretKey = secretKey . SecretKey ) ] ) Then you can use session in all handlers. You can set/get/clear session. proc login * ( ctx : Context ) {. async .} = ctx . session [ \"flywind\" ] = \"123\" ctx . session [ \"ordontfly\" ] = \"345\" resp \"<h1>Hello, Prologue!</h1>\" proc logout * ( ctx : Context ) {. async .} = resp $ ctx . session More session examples are in Session and Blog","title":"Session"},{"location":"session/#session","text":"The session helps with storing users' state.","title":"Session"},{"location":"session/#session-based-on-signed-cookie","text":"This session is based on signed cookie. It is not safe . You must not use it to store sensitive or important infos except for testing. Prologue provides sessionMiddleware to you.","title":"Session based on signed cookie"},{"location":"session/#usage","text":"First you should register sessionMiddleware in global middlewares or hanler's middlewares. var app = newApp ( settings = settings , middlewares = @[ sessionMiddleware ( secretKey = secretKey . SecretKey ) ] ) Then you can use session in all handlers. You can set/get/clear session. proc login * ( ctx : Context ) {. async .} = ctx . session [ \"flywind\" ] = \"123\" ctx . session [ \"ordontfly\" ] = \"345\" resp \"<h1>Hello, Prologue!</h1>\" proc logout * ( ctx : Context ) {. async .} = resp $ ctx . session More session examples are in Session and Blog","title":"Usage"},{"location":"staticfiles/","text":"Static Files Prologue supports serving static files. staticFileResponse You can use staticFileResponse to make a static file response. proc home ( ctx : Context ) {. async .} = await ctx . staticFileResponse ( \"hello.html\" , \"\" ) serve static files You can specify Settings.staticDirs attributes to serve multiple static dirs. staticDirs is of seq[string] type, it contains all the dirs of static files which will be checked in every request. let env = loadPrologueEnv ( \".env\" ) settings = newSettings ( staticDirs = [ env . get ( \"staticDir\" ) ] ) Or set staticDirs directly: let settings = newSettings ( staticDirs = [ \"/static\" , \"/templates\" ] )","title":"Static Files"},{"location":"staticfiles/#static-files","text":"Prologue supports serving static files.","title":"Static Files"},{"location":"staticfiles/#staticfileresponse","text":"You can use staticFileResponse to make a static file response. proc home ( ctx : Context ) {. async .} = await ctx . staticFileResponse ( \"hello.html\" , \"\" )","title":"staticFileResponse"},{"location":"staticfiles/#serve-static-files","text":"You can specify Settings.staticDirs attributes to serve multiple static dirs. staticDirs is of seq[string] type, it contains all the dirs of static files which will be checked in every request. let env = loadPrologueEnv ( \".env\" ) settings = newSettings ( staticDirs = [ env . get ( \"staticDir\" ) ] ) Or set staticDirs directly: let settings = newSettings ( staticDirs = [ \"/static\" , \"/templates\" ] )","title":"serve static files"},{"location":"uploadfile/","text":"Upload Files getUploadFile accepts the name of file input(HTNL) to get the info of file. The function returns the name and contents of the file. For this example, the name is \"file\". < form action = \"upload\" method = \"post\" enctype = \"multipart/form-data\" > < input type = \"file\" name = \"file\" value = \"eva\" > < input type = \"submit\" value = \"Submit\" name = \"submit\" > </ form > getUploadFile only works when you use form parameters and HttpPost method. Context module provides a helper function to save the uploadFile to disks. If you don't specify the name of the file, it will use the origin name from user. proc upload ( ctx : Context ) {. async .} = if ctx . request . reqMethod == HttpGet : await ctx . staticFileResponse ( \"tests/test_uploadFile/upload.html\" , \"\" ) elif ctx . request . reqMethod == HttpPost : let file = ctx . getUploadFile ( \"file\" ) file . save ( \"tests/test_uploadFile\" ) file . save ( \"tests/test_uploadFile\" , \"set.txt\" ) resp fmt\"<html><h1>{file.filename}</h1><p>{file.body}</p></html>\" The full example","title":"Upload Files"},{"location":"uploadfile/#upload-files","text":"getUploadFile accepts the name of file input(HTNL) to get the info of file. The function returns the name and contents of the file. For this example, the name is \"file\". < form action = \"upload\" method = \"post\" enctype = \"multipart/form-data\" > < input type = \"file\" name = \"file\" value = \"eva\" > < input type = \"submit\" value = \"Submit\" name = \"submit\" > </ form > getUploadFile only works when you use form parameters and HttpPost method. Context module provides a helper function to save the uploadFile to disks. If you don't specify the name of the file, it will use the origin name from user. proc upload ( ctx : Context ) {. async .} = if ctx . request . reqMethod == HttpGet : await ctx . staticFileResponse ( \"tests/test_uploadFile/upload.html\" , \"\" ) elif ctx . request . reqMethod == HttpPost : let file = ctx . getUploadFile ( \"file\" ) file . save ( \"tests/test_uploadFile\" ) file . save ( \"tests/test_uploadFile\" , \"set.txt\" ) resp fmt\"<html><h1>{file.filename}</h1><p>{file.body}</p></html>\" The full example","title":"Upload Files"}]}