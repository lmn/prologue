{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Prologue What's past is prologue. Purpose Prologue is a Full-Stack Web Framework which is ideal for building elegant and high performance web services. Reduce magic. Reduce surprise. Documentation You can read documentation in https://planety.github.io/prologue. Feature Core [x] Base on httpbeast and asynchttpserver [x] Configure and Settings [x] Context [x] Param and Query Data [x] Form Data [x] Static Files [x] Middleware [x] Simple Route [x] Regex Route [x] CORS Response [x] Signing [x] Cookie [x] Session [x] Cache [x] Startup and Shutdown Events [x] URL Building [x] Data Validation [x] Exception Handler [x] Cross-Site Request Forgery [x] Cross-Site Scripting (XSS) Protection(Karax quote string automatically) [x] Clickjacking Protection [x] Authentication [x] I18n Plugin [x] Minimal OpenApi support [x] Template(Using Karax Native) [x] Test Client(Using httpclient) Installation First you should install Nim language which is an elegant and high performance language.Follow the instructions and set environment variables correctly. Then you can use nimble command to install prologue. nimble install prologue Usage Hello World # app.nim import prologue proc hello * ( ctx : Context ) {. async .} = resp \"<h1>Hello, Prologue!</h1>\" let settings = newSettings () var app = newApp ( settings = settings ) app . addRoute ( \"/\" , hello ) app . run () Run app.nim .Now the server is running at localhost:8080. Another example # app.nim import prologue import prologue / middlewares / middlewares # Async Function proc home * ( ctx : Context ) {. async .} = resp \"<h1>Home</h1>\" proc helloName * ( ctx : Context ) {. async .} = resp \"<h1>Hello, \" & ctx . getPathParams ( \"name\" , \"Prologue\" ) & \"</h1>\" proc doRedirect * ( ctx : Context ) {. async .} = resp redirect ( \"/hello\" ) proc login * ( ctx : Context ) {. async .} = resp loginPage () proc do_login * ( ctx : Context ) {. async .} = resp redirect ( \"/hello/Nim\" ) let settings = newSettings ( appName = \"StarLight\" ) var app = newApp ( settings = settings , middlewares = @[ debugRequestMiddleware () ] ) app . addRoute ( \"/\" , home , @[ HttpGet , HttpPost ] ) app . addRoute ( \"/home\" , home , HttpGet ) app . addRoute ( \"/redirect\" , doRedirect , HttpGet ) app . addRoute ( \"/login\" , login , HttpGet ) app . addRoute ( \"/login\" , do_login , HttpPost , middlewares = @[ debugRequestMiddleware () ] ) app . addRoute ( \"/hello/{name}\" , helloName , HttpGet ) app . run () Run app.nim .Now the server is running at localhost:8080. More examples HelloWorld ToDoList Blog Stars","title":"Introduction"},{"location":"#prologue","text":"What's past is prologue.","title":"Prologue"},{"location":"#purpose","text":"Prologue is a Full-Stack Web Framework which is ideal for building elegant and high performance web services. Reduce magic. Reduce surprise.","title":"Purpose"},{"location":"#documentation","text":"You can read documentation in https://planety.github.io/prologue.","title":"Documentation"},{"location":"#feature","text":"Core [x] Base on httpbeast and asynchttpserver [x] Configure and Settings [x] Context [x] Param and Query Data [x] Form Data [x] Static Files [x] Middleware [x] Simple Route [x] Regex Route [x] CORS Response [x] Signing [x] Cookie [x] Session [x] Cache [x] Startup and Shutdown Events [x] URL Building [x] Data Validation [x] Exception Handler [x] Cross-Site Request Forgery [x] Cross-Site Scripting (XSS) Protection(Karax quote string automatically) [x] Clickjacking Protection [x] Authentication [x] I18n Plugin [x] Minimal OpenApi support [x] Template(Using Karax Native) [x] Test Client(Using httpclient)","title":"Feature"},{"location":"#installation","text":"First you should install Nim language which is an elegant and high performance language.Follow the instructions and set environment variables correctly. Then you can use nimble command to install prologue. nimble install prologue","title":"Installation"},{"location":"#usage","text":"","title":"Usage"},{"location":"#hello-world","text":"# app.nim import prologue proc hello * ( ctx : Context ) {. async .} = resp \"<h1>Hello, Prologue!</h1>\" let settings = newSettings () var app = newApp ( settings = settings ) app . addRoute ( \"/\" , hello ) app . run () Run app.nim .Now the server is running at localhost:8080.","title":"Hello World"},{"location":"#another-example","text":"# app.nim import prologue import prologue / middlewares / middlewares # Async Function proc home * ( ctx : Context ) {. async .} = resp \"<h1>Home</h1>\" proc helloName * ( ctx : Context ) {. async .} = resp \"<h1>Hello, \" & ctx . getPathParams ( \"name\" , \"Prologue\" ) & \"</h1>\" proc doRedirect * ( ctx : Context ) {. async .} = resp redirect ( \"/hello\" ) proc login * ( ctx : Context ) {. async .} = resp loginPage () proc do_login * ( ctx : Context ) {. async .} = resp redirect ( \"/hello/Nim\" ) let settings = newSettings ( appName = \"StarLight\" ) var app = newApp ( settings = settings , middlewares = @[ debugRequestMiddleware () ] ) app . addRoute ( \"/\" , home , @[ HttpGet , HttpPost ] ) app . addRoute ( \"/home\" , home , HttpGet ) app . addRoute ( \"/redirect\" , doRedirect , HttpGet ) app . addRoute ( \"/login\" , login , HttpGet ) app . addRoute ( \"/login\" , do_login , HttpPost , middlewares = @[ debugRequestMiddleware () ] ) app . addRoute ( \"/hello/{name}\" , helloName , HttpGet ) app . run () Run app.nim .Now the server is running at localhost:8080.","title":"Another example"},{"location":"#more-examples","text":"HelloWorld ToDoList Blog","title":"More examples"},{"location":"#stars","text":"","title":"Stars"},{"location":"application/","text":"application Prologue Object Prologue object Create a Prologue object Use newApp to get Prologue instance. Settings Use newSettings to create application settings. Middlewares Register middlewares for the whole application.The middlewares will apply to every handler. Startup and ShutUp Register event for startup and shutup.Support both sync and async proc. type AsyncEvent * = proc (): Future [ void ] {. closure , gcsafe .} SyncEvent * = proc () {. closure , gcsafe .} Error Handler Map status code to error handler.","title":"Application"},{"location":"application/#application","text":"","title":"application"},{"location":"application/#prologue-object","text":"Prologue object","title":"Prologue Object"},{"location":"application/#create-a-prologue-object","text":"Use newApp to get Prologue instance.","title":"Create a Prologue object"},{"location":"application/#settings","text":"Use newSettings to create application settings.","title":"Settings"},{"location":"application/#middlewares","text":"Register middlewares for the whole application.The middlewares will apply to every handler.","title":"Middlewares"},{"location":"application/#startup-and-shutup","text":"Register event for startup and shutup.Support both sync and async proc. type AsyncEvent * = proc (): Future [ void ] {. closure , gcsafe .} SyncEvent * = proc () {. closure , gcsafe .}","title":"Startup and ShutUp"},{"location":"application/#error-handler","text":"Map status code to error handler.","title":"Error Handler"},{"location":"context/","text":"Context Context object","title":"Context"},{"location":"context/#context","text":"Context object","title":"Context"},{"location":"event/","text":"Prologue supports both startup and shutdown events. startup events will be only executed once before the main loop. In contrast, shutdown events will be executed once after the main loop. Let's first look at the structure of Event , you can see that Event supports both synchronous and asynchronous closure function pointers. type AsyncEvent * = proc (): Future [ void ] {. closure , gcsafe .} SyncEvent * = proc () {. closure , gcsafe .} Event * = object case async * : bool of true : asyncHandler * : AsyncEvent of false : syncHandler * : SyncEvent You can use initEvent and pass function pointers to create Event . proc initEvent * ( handler : AsyncEvent ): Event {. inline .} = Event ( async : true , asyncHandler : handler ) proc initEvent * ( handler : SyncEvent ): Event {. inline .} = Event ( async : false , syncHandler : handler ) newApp has startup and shutdown parameters. You can pass a sequence of events to newApp . proc newApp * ( settings : Settings , middlewares : sink seq [ HandlerAsync ] = @[] , startup : seq [ Event ] = @[] , shutdown : seq [ Event ] = @[] , errorHandlerTable = DefaultErrorHandler , appData = newStringTable ( mode = modeCaseSensitive )): Prologue = Here is an example for a startup event(A shutdown event has the same usage as a startup event). proc setLoggingLevel () = addHandler ( newConsoleLogger ()) logging . setLogFilter ( lvlInfo ) let event = initEvent ( setLoggingLevel ) var app = newApp ( settings = settings , middlewares = @[ debugRequestMiddleware () ] , startup = @[ event ] )","title":"Event"},{"location":"middleware/","text":"","title":"Middleware"},{"location":"quickstart/","text":"Quick Start Now Let's begin a quick tour of Prologue . # app.nim import prologue proc hello * ( ctx : Context ) {. async .} = resp \"<h1>Hello, Prologue!</h1>\" let settings = newSettings () var app = newApp ( settings = settings ) app . addRoute ( \"/\" , hello ) app . run () This is a very basic \"Hello Prologue\" example.Run this script, visit http://localhost:8080 and you will see \"Hello, Prologue!\" in your browser! Here is how it works. First we import prologue to include all things we need in this example. Then let's look at hello function. It generates html or plain text or json or something else to our default http server(asynchttpserver). Function parameters ctx is of Context type. Context carry all things in every request. It includes request from http server and response which we transfer to http server Correspondingly and other useful attributes. In function body, we can find resp . resp is handy for generating response we need. It is equal to ctx.response = initResponse(\"<h1>Hello, Prologue!</h1>\") . Next let's configure our application.For this basic example, we will use default settings.You can specify parameters of newSettings of course.You can change to other port or set debug flag. Next let's add route to our application.Finally just run our application.","title":"QuickStart"},{"location":"quickstart/#quick-start","text":"Now Let's begin a quick tour of Prologue . # app.nim import prologue proc hello * ( ctx : Context ) {. async .} = resp \"<h1>Hello, Prologue!</h1>\" let settings = newSettings () var app = newApp ( settings = settings ) app . addRoute ( \"/\" , hello ) app . run () This is a very basic \"Hello Prologue\" example.Run this script, visit http://localhost:8080 and you will see \"Hello, Prologue!\" in your browser! Here is how it works. First we import prologue to include all things we need in this example. Then let's look at hello function. It generates html or plain text or json or something else to our default http server(asynchttpserver). Function parameters ctx is of Context type. Context carry all things in every request. It includes request from http server and response which we transfer to http server Correspondingly and other useful attributes. In function body, we can find resp . resp is handy for generating response we need. It is equal to ctx.response = initResponse(\"<h1>Hello, Prologue!</h1>\") . Next let's configure our application.For this basic example, we will use default settings.You can specify parameters of newSettings of course.You can change to other port or set debug flag. Next let's add route to our application.Finally just run our application.","title":"Quick Start"},{"location":"request/","text":"Request Request object","title":"Requests"},{"location":"request/#request","text":"Request object","title":"Request"},{"location":"response/","text":"Response Response object","title":"Response"},{"location":"response/#response","text":"Response object","title":"Response"},{"location":"route/","text":"Route Route is the core of web framework. Static Route Register handler hello by specifying path, httpMethod and middlewares. Default http method is HttpGet .If you register a handler with HttpGet , Prologue will automatically register HttpHead for this handler. # handler proc hello * ( ctx : Context ) {. async .} = resp \"<h1>Hello, Prologue!</h1>\" app . addRoute ( \"/hello\" , hello ) You can also use seq[httpMetod] to register same handler but support different http methods. # handler proc hello * ( ctx : Context ) {. async .} = resp \"<h1>Hello, Prologue!</h1>\" app . addRoute ( \"/hello\" , hello , @[ HttpGet , HttpPost ] ) Parameters Route Prologue support parameters route.You can use getPathParams to get name argument. proc helloName * ( ctx : Context ) {. async .} = resp \"<h1>Hello, \" & ctx . getPathParams ( \"name\" , \"Prologue\" ) & \"</h1>\" app . addRoute ( \"/hello/{name}\" , helloName , HttpGet ) Regex Route Prologue support regex route.You can use getPathParams to get name argument. proc articles * ( ctx : Context ) {. async .} = resp $ ctx . getPathParams ( \"num\" , 1 ) app . addRoute ( re\"/post(?P<num>[\\d]+)\" , articles , HttpGet )","title":"Route"},{"location":"route/#route","text":"Route is the core of web framework.","title":"Route"},{"location":"route/#static-route","text":"Register handler hello by specifying path, httpMethod and middlewares. Default http method is HttpGet .If you register a handler with HttpGet , Prologue will automatically register HttpHead for this handler. # handler proc hello * ( ctx : Context ) {. async .} = resp \"<h1>Hello, Prologue!</h1>\" app . addRoute ( \"/hello\" , hello ) You can also use seq[httpMetod] to register same handler but support different http methods. # handler proc hello * ( ctx : Context ) {. async .} = resp \"<h1>Hello, Prologue!</h1>\" app . addRoute ( \"/hello\" , hello , @[ HttpGet , HttpPost ] )","title":"Static Route"},{"location":"route/#parameters-route","text":"Prologue support parameters route.You can use getPathParams to get name argument. proc helloName * ( ctx : Context ) {. async .} = resp \"<h1>Hello, \" & ctx . getPathParams ( \"name\" , \"Prologue\" ) & \"</h1>\" app . addRoute ( \"/hello/{name}\" , helloName , HttpGet )","title":"Parameters Route"},{"location":"route/#regex-route","text":"Prologue support regex route.You can use getPathParams to get name argument. proc articles * ( ctx : Context ) {. async .} = resp $ ctx . getPathParams ( \"num\" , 1 ) app . addRoute ( re\"/post(?P<num>[\\d]+)\" , articles , HttpGet )","title":"Regex Route"},{"location":"staticfiles/","text":"Static Files","title":"Static Files"},{"location":"staticfiles/#static-files","text":"","title":"Static Files"}]}